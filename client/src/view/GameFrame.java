/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package view;

import com.google.gson.JsonObject;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import javax.swing.*;
import java.awt.Color;
import java.awt.Font;
import java.awt.GridLayout;
import java.awt.BorderLayout;
import java.awt.Dimension;

import controller.SocketHandler;

/**
 *
 * @author Admin
 */
public class GameFrame extends javax.swing.JFrame {
    
    private static final java.util.logging.Logger logger = java.util.logging.Logger.getLogger(GameFrame.class.getName());
    
    // Game state variables
    private String roomId = "";
    private int selfUserId = 0;
    private SocketHandler socketHandler;
    private final List<List<JTextField>> wordInputs = new ArrayList<>();
    // Countdown timer fields
    private javax.swing.Timer countdownTimer;
    private long matchEndTime = 0L; // epoch millis when match ends

    /**
     * Creates new form GameFrame
     */
    public GameFrame() {
        initComponents();
        // Ensure boardPanel can host dynamic grids in the left area
        boardPanel.setLayout(new java.awt.BorderLayout());
        renderPlaceholderBoard();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        boardPanel = new javax.swing.JPanel();
        javax.swing.JPanel infoPanel = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        lblName1 = new javax.swing.JLabel();
        lblName2 = new javax.swing.JLabel();
        lblScore1 = new javax.swing.JLabel();
        lblScore2 = new javax.swing.JLabel();
        chatPanel = new javax.swing.JPanel();
        jLabel8 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        txtChatArea = new javax.swing.JTextArea();
        txtMessage = new javax.swing.JTextField();
        btnSend = new javax.swing.JButton();

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 100, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 100, Short.MAX_VALUE)
        );

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Game Ô Chữ");
        getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        javax.swing.GroupLayout boardPanelLayout = new javax.swing.GroupLayout(boardPanel);
        boardPanel.setLayout(boardPanelLayout);
        boardPanelLayout.setHorizontalGroup(
            boardPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 570, Short.MAX_VALUE)
        );
        boardPanelLayout.setVerticalGroup(
            boardPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 680, Short.MAX_VALUE)
        );

        getContentPane().add(boardPanel, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0, 570, 680));

        jLabel1.setText("Chức năng");

        jButton1.setText("Thoát phòng");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jLabel2.setText("Người chơi");

        jLabel3.setText("Avt 1");

        jLabel4.setText("Avt 2");

        jLabel5.setText("x");

        jLabel6.setText("Thời gian");

        jLabel7.setText("jLabel7");

        lblName1.setText("tên 1");

        lblName2.setText("tên 2");

        lblScore1.setText("score 1");

        lblScore2.setText("jLabel9");

        javax.swing.GroupLayout infoPanelLayout = new javax.swing.GroupLayout(infoPanel);
        infoPanel.setLayout(infoPanelLayout);
        infoPanelLayout.setHorizontalGroup(
            infoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, infoPanelLayout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 167, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(243, 243, 243))
            .addGroup(infoPanelLayout.createSequentialGroup()
                .addGroup(infoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(infoPanelLayout.createSequentialGroup()
                        .addGroup(infoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(lblScore1, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblName1, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(87, 87, 87)
                        .addGroup(infoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblName2, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblScore2, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(infoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(infoPanelLayout.createSequentialGroup()
                            .addContainerGap()
                            .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 76, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGroup(infoPanelLayout.createSequentialGroup()
                            .addContainerGap()
                            .addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGroup(infoPanelLayout.createSequentialGroup()
                            .addGap(43, 43, 43)
                            .addComponent(jButton1))
                        .addGroup(infoPanelLayout.createSequentialGroup()
                            .addGap(102, 102, 102)
                            .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 16, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGroup(infoPanelLayout.createSequentialGroup()
                            .addGap(23, 23, 23)
                            .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGroup(infoPanelLayout.createSequentialGroup()
                            .addGap(83, 83, 83)
                            .addComponent(jLabel7, javax.swing.GroupLayout.PREFERRED_SIZE, 112, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        infoPanelLayout.setVerticalGroup(
            infoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(infoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jButton1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(infoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(jLabel4))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabel5)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 80, Short.MAX_VALUE)
                .addGroup(infoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblName1)
                    .addComponent(lblName2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(infoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblScore1)
                    .addComponent(lblScore2))
                .addGap(30, 30, 30)
                .addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel7)
                .addGap(28, 28, 28))
        );

        getContentPane().add(infoPanel, new org.netbeans.lib.awtextra.AbsoluteConstraints(570, 0, 220, 380));

        chatPanel.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        jLabel8.setText("Nhắn tin");
        chatPanel.add(jLabel8, new org.netbeans.lib.awtextra.AbsoluteConstraints(100, 0, 50, 30));

        txtChatArea.setEditable(false);
        txtChatArea.setColumns(20);
        txtChatArea.setLineWrap(true);
        txtChatArea.setRows(5);
        txtChatArea.setWrapStyleWord(true);
        jScrollPane1.setViewportView(txtChatArea);

        chatPanel.add(jScrollPane1, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 40, 200, 210));

        txtMessage.setToolTipText("");
        txtMessage.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                txtMessageMouseClicked(evt);
            }
        });
        txtMessage.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                txtMessageActionPerformed(evt);
            }
        });
        chatPanel.add(txtMessage, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 260, 160, -1));

        btnSend.setText("Gửi");
        btnSend.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSendActionPerformed(evt);
            }
        });
        chatPanel.add(btnSend, new org.netbeans.lib.awtextra.AbsoluteConstraints(170, 260, 50, -1));

        getContentPane().add(chatPanel, new org.netbeans.lib.awtextra.AbsoluteConstraints(570, 390, 220, 290));

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        int result = JOptionPane.showConfirmDialog(rootPane, "Bạn có chắc chắn muốn thoát phòng không?",
                "Xác nhận", JOptionPane.YES_NO_OPTION);
        if (result == JOptionPane.YES_OPTION) {
            // Send leave room message to server
            if (socketHandler != null) {
                JsonObject payload = new JsonObject();
                payload.addProperty("roomId", roomId);
                socketHandler.sendMessage("LEAVE_ROOM", payload);
            }
            dispose();
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    private void txtMessageActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_txtMessageActionPerformed
        sendChatMessage();
    }//GEN-LAST:event_txtMessageActionPerformed

    private void btnSendActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSendActionPerformed
        sendChatMessage();
    }//GEN-LAST:event_btnSendActionPerformed

    private void sendChatMessage() {
        String message = txtMessage.getText().trim();
        if (!message.isEmpty()) {
            txtMessage.setText(""); // xóa ô nhập
            
            // Send chat message to server
            if (socketHandler != null) {
                JsonObject payload = new JsonObject();
                payload.addProperty("roomId", roomId);
                payload.addProperty("message", message);
                socketHandler.sendMessage("CHAT_MESSAGE", payload);
            }
        }
    }

    private void txtMessageMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_txtMessageMouseClicked

    }//GEN-LAST:event_txtMessageMouseClicked

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ReflectiveOperationException | javax.swing.UnsupportedLookAndFeelException ex) {
            logger.log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> new GameFrame().setVisible(true));
    }

    // Game methods for handling match data
    public void loadMatchStart(JsonObject envelope) {
        // envelope: { action:"match_start", roomId, data: { words, players, startTime, endTime, ... } }
        this.roomId = envelope.has("roomId") ? envelope.get("roomId").getAsString() : this.roomId;
        JsonObject data = envelope.has("data") ? envelope.get("data").getAsJsonObject() : envelope;
        renderWords(data);
        updateScores(data);
        updateTimer(data);
    }

    public void loadMatchUpdate(JsonObject envelope) {
        JsonObject data = envelope.has("data") ? envelope.get("data").getAsJsonObject() : envelope;
        refreshFilled(data);
        updateScores(data);
        updateTimer(data);
    }

    private void renderWords(JsonObject data) {
        boardPanel.removeAll();
        wordInputs.clear();

        JsonArray words = data.getAsJsonArray("words");
        if (words == null || words.size() == 0) {
            renderPlaceholderBoard();
            boardPanel.revalidate();
            boardPanel.repaint();
            return;
        }

        // Create a container panel for words
        JPanel wordsContainer = new JPanel();
        wordsContainer.setLayout(new GridLayout(words.size(), 1, 5, 5));
        wordsContainer.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // Determine per-player revealed patterns (server now includes per-player map 'playerRevealed')
        JsonObject playerRevealed = data.has("playerRevealed") ? data.getAsJsonObject("playerRevealed") : null;
        JsonArray myRevealedArray = null;
        if (playerRevealed != null && selfUserId > 0) {
            String key = String.valueOf(selfUserId);
            if (playerRevealed.has(key)) {
                try { myRevealedArray = playerRevealed.getAsJsonArray(key); } catch (Exception ignored) {}
            }
        }

        for (int wi = 0; wi < words.size(); wi++) {
            JsonObject w = words.get(wi).getAsJsonObject();
            String hint = w.has("hint") ? w.get("hint").getAsString() : "";
            int len = w.has("length") ? w.get("length").getAsInt() : 0;

            JPanel row = new JPanel(new BorderLayout(10, 10));
            row.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
            
            JLabel hintLabel = new JLabel(hint);
            hintLabel.setPreferredSize(new Dimension(200, 30));
            hintLabel.setFont(new Font("Arial", Font.BOLD, 14));
            hintLabel.setBorder(BorderFactory.createEmptyBorder(0, 10, 0, 10));
            row.add(hintLabel, BorderLayout.WEST);

            JPanel cells = new JPanel(new GridLayout(1, Math.max(1, len), 3, 3));
            List<JTextField> inputs = new ArrayList<>();
            for (int i = 0; i < len; i++) {
                JTextField tf = new JTextField(1);
                tf.setHorizontalAlignment(JTextField.CENTER);
                tf.setFont(new Font("Consolas", Font.BOLD, 18));
                tf.setBorder(BorderFactory.createLineBorder(Color.GRAY, 2));
                tf.setPreferredSize(new Dimension(35, 35));
                tf.setBackground(Color.WHITE);
                // If server provided per-player revealed pattern, prefill revealed letters and disable editing for them
                String revealed = null;
                if (myRevealedArray != null && wi < myRevealedArray.size()) {
                    try { revealed = myRevealedArray.get(wi).getAsString(); } catch (Exception ignored) { revealed = null; }
                }
                // Fallback to top-level revealed if present (backwards compatibility)
                if ((revealed == null || revealed.isEmpty()) && w.has("revealed")) {
                    revealed = w.get("revealed").getAsString();
                }

                if (revealed != null && revealed.length() > i) {
                    char rc = revealed.charAt(i);
                    if (rc != '_' && rc != '\u0000') {
                        tf.setText(String.valueOf(rc));
                        tf.setEditable(false);
                        tf.setBackground(new Color(220, 220, 220));
                        tf.setForeground(Color.BLACK);
                    }
                }
                final int wordIdx = wordInputs.size();
                final int charIdx = i;
                tf.addKeyListener(new KeyAdapter() {
                    @Override
                    public void keyTyped(KeyEvent e) {
                        // Do nothing if field is not editable (fixed hint)
                        if (!tf.isEditable()) { e.consume(); return; }
                        char ch = e.getKeyChar();
                        if (Character.isLetter(ch)) {
                            tf.setText(("" + ch).toUpperCase());
                            tf.setBackground(Color.LIGHT_GRAY);
                            sendMatchInput(wordIdx, charIdx, Character.toUpperCase(ch));
                            // Move focus to next cell
                            SwingUtilities.invokeLater(() -> focusNext(inputs, charIdx));
                            // Prevent default insertion of the typed char (avoids duplicate lowercase)
                            e.consume();
                        } else {
                            e.consume();
                        }
                    }
                    
                    @Override
                    public void keyPressed(KeyEvent e) {
                        if (e.getKeyCode() == KeyEvent.VK_BACK_SPACE) {
                            if (!tf.isEditable()) { e.consume(); return; }
                            tf.setText("");
                            tf.setBackground(Color.WHITE);
                            // Move focus to previous cell
                            SwingUtilities.invokeLater(() -> focusPrevious(inputs, charIdx));
                        }
                    }
                });

                // keep existing text (revealed letter or underscore) so hint is visible
                inputs.add(tf);
                cells.add(tf);
            }
            row.add(cells, BorderLayout.CENTER);
            wordsContainer.add(row);
            wordInputs.add(inputs);
        }

        // Add the container to boardPanel using BorderLayout center
        boardPanel.add(wordsContainer, java.awt.BorderLayout.CENTER);
        boardPanel.revalidate();
        boardPanel.repaint();
        // Normalize any labels that show an Upper+lower pair (e.g. "Mm") to only uppercase
        normalizeUpperLowerLabels(boardPanel);
    }

    private void renderPlaceholderBoard() {
        boardPanel.removeAll();
        wordInputs.clear();

        javax.swing.JPanel wordsContainer = new javax.swing.JPanel();
        wordsContainer.setLayout(new java.awt.GridLayout(5, 1, 5, 5));
        wordsContainer.setBorder(javax.swing.BorderFactory.createEmptyBorder(10, 10, 10, 10));

        for (int r = 0; r < 5; r++) {
            javax.swing.JPanel row = new javax.swing.JPanel(new java.awt.BorderLayout(10, 10));
            row.setBorder(javax.swing.BorderFactory.createEmptyBorder(5, 5, 5, 5));

            javax.swing.JLabel hintLabel = new javax.swing.JLabel("Từ " + (r + 1));
            hintLabel.setPreferredSize(new java.awt.Dimension(200, 30));
            hintLabel.setFont(new java.awt.Font("Arial", java.awt.Font.BOLD, 14));
            hintLabel.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 10, 0, 10));
            row.add(hintLabel, java.awt.BorderLayout.WEST);

            int len = 8;
            javax.swing.JPanel cells = new javax.swing.JPanel(new java.awt.GridLayout(1, len, 3, 3));
            java.util.List<javax.swing.JTextField> inputs = new java.util.ArrayList<>();
            for (int i = 0; i < len; i++) {
                javax.swing.JTextField tf = new javax.swing.JTextField(1);
                tf.setHorizontalAlignment(javax.swing.JTextField.CENTER);
                tf.setFont(new java.awt.Font("Consolas", java.awt.Font.BOLD, 18));
                tf.setBorder(javax.swing.BorderFactory.createLineBorder(java.awt.Color.GRAY, 2));
                tf.setPreferredSize(new java.awt.Dimension(35, 35));
                tf.setBackground(java.awt.Color.WHITE);
                tf.setText("");
                inputs.add(tf);
                cells.add(tf);
            }
            row.add(cells, java.awt.BorderLayout.CENTER);
            wordsContainer.add(row);
            wordInputs.add(inputs);
        }

        boardPanel.add(wordsContainer, java.awt.BorderLayout.CENTER);
        boardPanel.revalidate();
        boardPanel.repaint();
        normalizeUpperLowerLabels(boardPanel);
    }

    /**
     * Walk component tree and convert labels that display an Upper+lower pair
     * (like "Mm") into a single uppercase character "M".
     */
    private void normalizeUpperLowerLabels(java.awt.Container root) {
        for (java.awt.Component comp : root.getComponents()) {
            if (comp instanceof javax.swing.JLabel) {
                javax.swing.JLabel lbl = (javax.swing.JLabel) comp;
                String t = lbl.getText();
                if (t != null && t.length() == 2) {
                    char a = t.charAt(0);
                    char b = t.charAt(1);
                    if (Character.isUpperCase(a) && Character.isLowerCase(b) && Character.toUpperCase(b) == a) {
                        lbl.setText(String.valueOf(a));
                    }
                }
            } else if (comp instanceof java.awt.Container) {
                normalizeUpperLowerLabels((java.awt.Container) comp);
            }
        }
    }

    private void refreshFilled(JsonObject data) {
        // Update local input fields according to server-authoritative per-player revealed patterns.
        // Behavior:
        // - For revealed/fixed cells (server shows a letter), set the cell text and make it non-editable.
        // - For non-revealed cells: if the local user has already completed the word (all editable cells non-empty),
        //   then clear any cells that the server does not consider revealed (i.e., wrong letters).
        // - Otherwise leave local typed letters until server broadcasts an update after a full attempt.
        if (wordInputs.isEmpty()) return;

        JsonObject playerRevealed = data.has("playerRevealed") ? data.getAsJsonObject("playerRevealed") : null;
        JsonArray myRevealedArray = null;
        if (playerRevealed != null && selfUserId > 0) {
            String key = String.valueOf(selfUserId);
            if (playerRevealed.has(key)) {
                try { myRevealedArray = playerRevealed.getAsJsonArray(key); } catch (Exception ignored) {}
            }
        }

        for (int wi = 0; wi < wordInputs.size(); wi++) {
            List<JTextField> inputs = wordInputs.get(wi);
            String revealed = null;
            if (myRevealedArray != null && wi < myRevealedArray.size()) {
                try { revealed = myRevealedArray.get(wi).getAsString(); } catch (Exception ignored) { revealed = null; }
            }

            // Determine if the local user has filled all editable cells for this word
            boolean localComplete = true;
            for (JTextField tf : inputs) {
                if (tf.isEditable()) {
                    if (tf.getText() == null || tf.getText().trim().isEmpty()) { localComplete = false; break; }
                }
            }

            for (int ci = 0; ci < inputs.size(); ci++) {
                JTextField tf = inputs.get(ci);
                char rc = '_';
                if (revealed != null && revealed.length() > ci) rc = revealed.charAt(ci);

                if (rc != '_' && rc != '\u0000') {
                    // Server says this cell is revealed/correct — enforce it
                    tf.setText(String.valueOf(rc));
                    tf.setEditable(false);
                    tf.setBackground(new Color(220, 220, 220));
                    tf.setForeground(Color.BLACK);
                } else {
                    // Not revealed: only clear local wrong letters when the user had completed the word
                    if (localComplete) {
                        String cur = tf.getText();
                        if (cur != null && !cur.trim().isEmpty()) {
                            // Clear wrong letter (server does not show it as revealed)
                            tf.setText("");
                            tf.setBackground(Color.WHITE);
                            tf.setEditable(true);
                            tf.setForeground(Color.BLACK);
                        } else {
                            tf.setEditable(true);
                            tf.setBackground(Color.WHITE);
                            tf.setForeground(Color.BLACK);
                        }
                    } else {
                        // don't clear mid-word typed letters; leave editable state as-is
                        if (tf.isEditable()) {
                            tf.setBackground(Color.WHITE);
                            tf.setForeground(Color.BLACK);
                        }
                    }
                }
            }
        }
    }

    private void updateScores(JsonObject data) {
        JsonObject players = data.has("players") ? data.get("players").getAsJsonObject() : null;
        if (players == null) return;
        
        // players is a map keyed by userId (numbers become strings in JSON)
        for (Map.Entry<String, JsonElement> e : players.entrySet()) {
            JsonObject ps = e.getValue().getAsJsonObject();
            int score = ps.has("score") ? ps.get("score").getAsInt() : 0;
            try {
                int uid = Integer.parseInt(e.getKey());
                if (uid == selfUserId) {
                    lblScore1.setText("" + score);
                    lblScore1.setFont(new Font("Arial", Font.BOLD, 16));
                } else {
                    lblScore2.setText("" + score);
                    lblScore2.setFont(new Font("Arial", Font.BOLD, 16));
                }
            } catch (NumberFormatException ignored) {}
        }
    }

    private void updateTimer(JsonObject data) {
        // Read endTime from server payload and start a client-side countdown
        long now = System.currentTimeMillis();
        long end = data.has("endTime") ? data.get("endTime").getAsLong() : now;
        matchEndTime = end;
        long remain = Math.max(0, matchEndTime - now);

        updateTimerFromMillis(remain);

        // Start or restart the Swing timer to update UI continuously
        startCountdown();
    }

    private void updateTimerFromMillis(long remain) {
        long sec = remain / 1000;
        long min = sec / 60;
        sec = sec % 60;

        String timeText = String.format("%02d:%02d", min, sec);
        jLabel7.setText(timeText);
        jLabel7.setFont(new Font("Arial", Font.BOLD, 18));

        // Change color when time is running out
        if (remain <= 0) {
            jLabel7.setForeground(Color.RED);
        } else if (remain < 30000) { // Less than 30 seconds
            jLabel7.setForeground(Color.RED);
        } else if (remain < 60000) { // Less than 1 minute
            jLabel7.setForeground(Color.ORANGE);
        } else {
            jLabel7.setForeground(Color.BLACK);
        }
    }

    private void startCountdown() {
        if (countdownTimer != null && countdownTimer.isRunning()) return;

        countdownTimer = new javax.swing.Timer(500, new java.awt.event.ActionListener() {
            @Override
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                long now = System.currentTimeMillis();
                long remain = Math.max(0, matchEndTime - now);
                updateTimerFromMillis(remain);
                if (remain <= 0) {
                    // stop when time reaches zero
                    stopCountdown();
                }
            }
        });
        countdownTimer.setCoalesce(true);
        countdownTimer.start();
    }

    private void stopCountdown() {
        if (countdownTimer != null) {
            countdownTimer.stop();
            countdownTimer = null;
        }
    }

    private void focusNext(List<JTextField> inputs, int currentIdx) {
        int next = Math.min(currentIdx + 1, inputs.size() - 1);
        if (next >= 0 && next < inputs.size()) {
            inputs.get(next).requestFocusInWindow();
            inputs.get(next).selectAll();
        }
    }

    private void focusPrevious(List<JTextField> inputs, int currentIdx) {
        int prev = Math.max(currentIdx - 1, 0);
        if (prev >= 0 && prev < inputs.size()) {
            inputs.get(prev).requestFocusInWindow();
            inputs.get(prev).selectAll();
        }
    }

    private void sendMatchInput(int wordIdx, int charIdx, char ch) {
        if (socketHandler != null) {
            JsonObject payload = new JsonObject();
            payload.addProperty("roomId", roomId);
            payload.addProperty("wordIdx", wordIdx);
            payload.addProperty("charIdx", charIdx);
            payload.addProperty("ch", String.valueOf(ch));
            socketHandler.sendMessage("MATCH_INPUT", payload);
        } else {
            logger.info("Match input: wordIdx=" + wordIdx + ", charIdx=" + charIdx + ", ch=" + ch);
        }
    }

    public void setSelfUserId(int userId) {
        this.selfUserId = userId;
    }

    public void setSocketHandler(SocketHandler socketHandler) {
        this.socketHandler = socketHandler;
    }

    public void setPlayerNames(String name1, String name2) {
        lblName1.setText(name1);
        lblName2.setText(name2);
    }

    public void receiveChatMessage(String senderName, String message) {
        txtChatArea.append(senderName + ": " + message + "\n");
        txtChatArea.setCaretPosition(txtChatArea.getDocument().getLength());
    }

    public void showGameMessage(String message) {
        txtChatArea.append("Hệ thống: " + message + "\n");
        txtChatArea.setCaretPosition(txtChatArea.getDocument().getLength());
    }

    public void clearBoard() {
        boardPanel.removeAll();
        wordInputs.clear();
        boardPanel.revalidate();
        boardPanel.repaint();
        // Ensure client-side countdown stops when board is cleared
        stopCountdown();
    }

    @Override
    public void dispose() {
        // Stop any running countdown to avoid timers running after window closed
        stopCountdown();
        super.dispose();
    }

    public void highlightCorrectWord(int wordIdx) {
        if (wordIdx >= 0 && wordIdx < wordInputs.size()) {
            List<JTextField> inputs = wordInputs.get(wordIdx);
            for (JTextField tf : inputs) {
                tf.setBackground(Color.GREEN);
                tf.setForeground(Color.WHITE);
            }
        }
    }

    public void highlightIncorrectWord(int wordIdx) {
        if (wordIdx >= 0 && wordIdx < wordInputs.size()) {
            List<JTextField> inputs = wordInputs.get(wordIdx);
            for (JTextField tf : inputs) {
                tf.setBackground(Color.RED);
                tf.setForeground(Color.WHITE);
            }
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel boardPanel;
    private javax.swing.JButton btnSend;
    private javax.swing.JPanel chatPanel;
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel lblName1;
    private javax.swing.JLabel lblName2;
    private javax.swing.JLabel lblScore1;
    private javax.swing.JLabel lblScore2;
    private javax.swing.JTextArea txtChatArea;
    private javax.swing.JTextField txtMessage;
    // End of variables declaration//GEN-END:variables
}
